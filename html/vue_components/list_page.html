<style>
ul.list-top li {
	margin-left:0.5rem;
	margin-right:0.5rem;
}
</style>

<template id='list-page-template'>
<div class="container-fluid mt-2">
<div class="row">
	<div class="col-md-12" v-if='!loading'>
		<h1><span tt='list_with_number' :tt1='list_id'></span>: {{list.list.name}}</h1>
		<div>
			<ul class="pagination list-top">
				<li>
					<span tt='revision'></span>
					<select v-model='revision_id' class="form-control" style="display:inline; width:auto;" @change='change_revision'>
						<option v-for='revid in revisions' :value='revid'>{{revid}}</option>
					</select>
				</li>
				<li style="padding-top:0.4rem;" tt='total_rows' :tt1='list.total'></li>
				<li style="padding-top:0.4rem;">
					<button class="btn btn-outline-secondary" href="#" @click.prevent="snapshot" tt='snapshot' style="margin-top: -0.4rem;"></button>
				</li>
				<li>
					<select v-model="download_type" class="form-control" style="display: inline-block; width: auto;" @change="set_download_url">
						<option value='csv' tt='csv'></option>
						<option value='tsv' tt='tsv'></option>
						<option value='json' tt='json'></option>
					</select>
					<a :href="download_url" tt_title="download" :download="'gulp.list.'+list.list.id+'.'+list.revision_id+'.'+download_type">
						<img :src="download_icon_url"/>
					</a>
				</li>
				<li>
					<router-link :to="'/update/'+list.list.id" tt="update"></router-link>
				</li>
		</div>
		<list :list='list' :revision_id='revision_id'></list>
	</div>
  </div>
</div>
</template>

<script>
'use strict';


let ListPage = Vue.extend ( {
    props : ['list_id','initial_revision_id'] ,
    data : function () { return { list:{} , revision_id:0 , revisions:[] , download_type:'tsv' , download_url:'' , loading:true ,
    	download_icon_url:'https://upload.wikimedia.org/wikipedia/commons/thumb/f/f5/Cloud_Download_-_The_Noun_Project.svg/32px-Cloud_Download_-_The_Noun_Project.svg.png'
	} } ,
    created : function () {
    	this.load_list(()=>{
    	    this.fix_columns();
    	    this.set_download_url();
    		this.loading=false
    	})
    },
    updated : function () { tt.updateInterface(this.$el) } ,
    mounted : function () { tt.updateInterface(this.$el) } ,
    methods : {
    	change_revision() {
    		if ( this.revision_id==this.list.list.revision_id ) {
    			// Last (default) revision
    			this.$router.push ("/list/"+this.list.list.id);
    		} else {
    			// Specific revision
	    		this.$router.push ("/list/"+this.list.list.id+"/"+this.revision_id);
    		}
    	} ,
    	set_download_url() {
    		let url = "//gulp.toolforge.org/list/rows/"+this.list.list.id+"?format="+this.download_type ;
    		if ( this.revision_id!=this.list.list.revision_id ) url += "&revision_id="+this.revision_id;
    		this.download_url = url;
    	} ,
    	snapshot() {
    		let url = "/list/snapshot/"+this.list.list.id;
            fetch(url)
                .then((response) => response.json())
                .then((d) => {
                	if ( d.old_revision_id==d.new_revision_id) {
                		alert(tt.t("no_new_revision").replace('$1',this.list.revision_id))
                	} else {
                		this.list.list.revision_id = d.new_revision_id;
                		this.revision_id = d.new_revision_id;
                		this.change_revision()
                	}
                })
    	} ,
        load_list(resolve) {
        	let url = "/list/info/"+this.list_id;
        	if ( typeof this.initial_revision_id!='undefined') url += "?revision_id="+this.initial_revision_id;
            fetch(url)
                .then((response) => response.json())
                .then((d) => this.list=d)
                .then(() => {
                	if ( typeof this.initial_revision_id=='undefined') this.revision_id=this.list.list.revision_id;
                	else this.revision_id=this.initial_revision_id;
                	this.revisions = [...Array(this.list.list.revision_id+1).keys()];
                	this.revisions.reverse()
                })
                .then(resolve)
        } ,
		fix_columns() {
            this.list.list.header.schema.columns.forEach(function(c,idx){
            	if ( typeof c.label!='undefined' ) return ; // Already has a label
            	if ( c.column_type=='WikiPage' ) {
            		c.label = c.wiki.replace(/wiki$/,'') ;
            		c.label = c.label.charAt(0).toUpperCase() + c.label.slice(1);
            		if ( c.wiki=='wikidatawiki' ) {
            			if (c.namespace_id==0) c.label += " item";
            			else if (c.namespace_id==120) c.label += " property";
            			else c.label += " page";
            		} else if ( c.wiki=='commonswiki' ) {
            			if (c.namespace_id==6) c.label += " file";
            			else c.label += " page";
            		} else c.label += " page";
            	} else c.label = "Column "+idx;
            });
        } ,

    } ,
    template:'#list-page-template'
} );
</script>